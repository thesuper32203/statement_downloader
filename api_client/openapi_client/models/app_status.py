# coding: utf-8

"""
    Open Finance

    OpenAPI specification for Finicity APIs.  Open Finance (formerly Open Banking) solutions in the US are provided by Finicity, a Mastercard company.

    The version of the OpenAPI document: 1.31.2
    Contact: apisupport@mastercard.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.app_financial_institution_status import AppFinancialInstitutionStatus
from typing import Optional, Set
from typing_extensions import Self

class AppStatus(BaseModel):
    """
    Registration status details for the application
    """ # noqa: E501
    partner_id: StrictStr = Field(description="Your Partner ID displayed in the [Developer Dashboard](https://developer.mastercard.com/account/log-in)", alias="partnerId")
    pre_app_id: StrictStr = Field(description="Identifier to track the application registration from the App Registration and Get App Registration Status APIs", alias="preAppId")
    note: Optional[StrictStr] = Field(default=None, description="A note on the registration. Typically used to indicate reasons for rejected apps.")
    application_id: Optional[StrictStr] = Field(default=None, description="`applicationId` value returned from the Get App Registration Status API and the partner assign the customers to. This cannot be changed once set. Only applicable in cases of partners with multiple registered applications. If the partner only has one app, this can usually be omitted. This field is populated after the app is in a status approved.", alias="applicationId")
    app_name: StrictStr = Field(description="The name of the application assigned to the customer", alias="appName")
    submitted_date: StrictInt = Field(description="A date in Unix epoch time (in seconds). See: [Handling Epoch Dates and Times](https://developer.mastercard.com/open-banking-us/documentation/codes-and-formats/).", alias="submittedDate")
    modified_date: StrictInt = Field(description="A date in Unix epoch time (in seconds). See: [Handling Epoch Dates and Times](https://developer.mastercard.com/open-banking-us/documentation/codes-and-formats/).", alias="modifiedDate")
    status: StrictStr = Field(description="The status of an app registration request. \"A\" means approved. \"P\" means pending which is the status when initially submitted or when the app is modified and awaiting approval. \"R\" means rejected. If it is rejected there will be a note with the rejected reason. \"S\" stands for \"Skipped\" and indicates that app registration with the data provider will not be required.")
    scopes: Optional[StrictStr] = Field(default=None, description="Indicates scopes of data accessible to the app")
    institution_details: Optional[List[AppFinancialInstitutionStatus]] = Field(default=None, description="A list of the registration status for each FI for the application", alias="institutionDetails")
    __properties: ClassVar[List[str]] = ["partnerId", "preAppId", "note", "applicationId", "appName", "submittedDate", "modifiedDate", "status", "scopes", "institutionDetails"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AppStatus from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in institution_details (list)
        _items = []
        if self.institution_details:
            for _item_institution_details in self.institution_details:
                if _item_institution_details:
                    _items.append(_item_institution_details.to_dict())
            _dict['institutionDetails'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AppStatus from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "partnerId": obj.get("partnerId"),
            "preAppId": obj.get("preAppId"),
            "note": obj.get("note"),
            "applicationId": obj.get("applicationId"),
            "appName": obj.get("appName"),
            "submittedDate": obj.get("submittedDate"),
            "modifiedDate": obj.get("modifiedDate"),
            "status": obj.get("status"),
            "scopes": obj.get("scopes"),
            "institutionDetails": [AppFinancialInstitutionStatus.from_dict(_item) for _item in obj["institutionDetails"]] if obj.get("institutionDetails") is not None else None
        })
        return _obj


