# coding: utf-8

"""
    Open Finance

    OpenAPI specification for Finicity APIs.  Open Finance (formerly Open Banking) solutions in the US are provided by Finicity, a Mastercard company.

    The version of the OpenAPI document: 1.31.2
    Contact: apisupport@mastercard.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.deposit_switch_details_distributions_inner import DepositSwitchDetailsDistributionsInner
from openapi_client.models.deposit_switch_details_provider import DepositSwitchDetailsProvider
from typing import Optional, Set
from typing_extensions import Self

class DepositSwitchDetails(BaseModel):
    """
    DepositSwitchDetails
    """ # noqa: E501
    customer_id: StrictStr = Field(description="A customer ID", alias="customerId")
    customer_type: StrictStr = Field(description="The type of Mastercard Open Finance customer (`active` or `testing`)", alias="customerType")
    switch_id: StrictStr = Field(description="Deposit switch ID", alias="switchId")
    switch_status: StrictStr = Field(description="Deposit switch status. Possible values include `processing`, `completed`, or `failed`.  * processing - The deposit switch is currently being processed. * completed - The deposit switch has been completed successfully. * failed - The deposit switch has failed. Refer to failureReason for more details. ", alias="switchStatus")
    failure_reason: Optional[StrictStr] = Field(default=None, description="Deposit switch failure reason. Possible values include - * account-lockout - The account is locked out, most likely the end user has had too many failed attempts. * account-setup-incomplete - The user's account in the payroll system is not fully set up and will require additional information from the user. * account-unusable - The user's bank account is unusable for the selected product or use case. * bad-credentials - Either the username or password was incorrect. This is our most common fail reason. * connection-error - A network error occurred which caused the connection between our system and the payroll system to be lost. * distribution-not-supported - The payroll system did not support the type of distribution requested. For example, the user attempted to allocate a percentage of their paycheck, but is only eligible for fixed amounts and remainder/net balance. * device-disconnected - The device used to start the task is no longer connected. * enrolled-in-paycard - The user is enrolled in a paycard program instead of direct deposit via their bank. * expired - The user's password has expired and they must create a new one. * no-data-found - No verify data was found for the user. * product-not-supported - The payroll system did not allow the action to be taken. Many payroll systems allow HR to customize what is allowed in their system. Direct Deposit may be allowed by a payroll system, but may be disallowed by a specific employer. Therefore, when an employee of that company goes to set up Direct Deposit it is rejected, resulting in this error code. * routing-number-not-supported - The account did not support the routing number entered. * session-timeout - The user's session timed out. * system-unavailable - The system was unavailable. For example, the site is undergoing maintenance or it is outside the window of scheduled availability for the site. * transaction-pending - There is a deposit allocation already in progress and additional updates cannot be made at this time. For example, if an employer has an approval process in place, they may disallow modifications until the update has been processed. * unknown-failure - We encountered an unexpected error. * user-abandon - The user was asked an MFA question, but did not answer the question. * work-status-terminated - The task could not be completed because the user's employment has been terminated. ", alias="failureReason")
    created_date: StrictStr = Field(description="Date and time in ISO 8601 format (YYYY-MM-DDThh:mm:ssZ) when deposit switch was performed", alias="createdDate")
    updated_date: StrictStr = Field(description="Date and time in ISO 8601 format (YYYY-MM-DDThh:mm:ssZ) when deposit switch status was updated", alias="updatedDate")
    authenticated: Optional[StrictBool] = Field(default=None, description="Indicates whether or not the deposit switch task has successfully authenticated against the payroll system")
    provider: DepositSwitchDetailsProvider
    distributions: List[DepositSwitchDetailsDistributionsInner] = Field(description="Deposit switch distribution details")
    __properties: ClassVar[List[str]] = ["customerId", "customerType", "switchId", "switchStatus", "failureReason", "createdDate", "updatedDate", "authenticated", "provider", "distributions"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DepositSwitchDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of provider
        if self.provider:
            _dict['provider'] = self.provider.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in distributions (list)
        _items = []
        if self.distributions:
            for _item_distributions in self.distributions:
                if _item_distributions:
                    _items.append(_item_distributions.to_dict())
            _dict['distributions'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DepositSwitchDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "customerId": obj.get("customerId"),
            "customerType": obj.get("customerType"),
            "switchId": obj.get("switchId"),
            "switchStatus": obj.get("switchStatus"),
            "failureReason": obj.get("failureReason"),
            "createdDate": obj.get("createdDate"),
            "updatedDate": obj.get("updatedDate"),
            "authenticated": obj.get("authenticated"),
            "provider": DepositSwitchDetailsProvider.from_dict(obj["provider"]) if obj.get("provider") is not None else None,
            "distributions": [DepositSwitchDetailsDistributionsInner.from_dict(_item) for _item in obj["distributions"]] if obj.get("distributions") is not None else None
        })
        return _obj


