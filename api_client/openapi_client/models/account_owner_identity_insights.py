# coding: utf-8

"""
    Open Finance

    OpenAPI specification for Finicity APIs.  Open Finance (formerly Open Banking) solutions in the US are provided by Finicity, a Mastercard company.

    The version of the OpenAPI document: 1.31.2
    Contact: apisupport@mastercard.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.device_insights import DeviceInsights
from typing import Optional, Set
from typing_extensions import Self

class AccountOwnerIdentityInsights(BaseModel):
    """
    List of account owner Identity Insights
    """ # noqa: E501
    request_ref_id: Optional[StrictStr] = Field(default=None, description="The generated unique web transaction identifier.", alias="requestRefId")
    is_email_valid: Optional[StrictBool] = Field(default=None, description="True if the email address is valid.", alias="isEmailValid")
    email_first_seen_days: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Count of days since the email was first observed in Ekata's Identity Network. If the email has not been observed before, first_seen_days will be 0.", alias="emailFirstSeenDays")
    email_domain_creation_date: Optional[StrictStr] = Field(default=None, description="Returns a date that the email domain was created.", alias="emailDomainCreationDate")
    email_to_name: Optional[StrictStr] = Field(default=None, description="The match status between the input name and the queried entity. * not found * match * no-match", alias="emailToName")
    ip_risk: Optional[StrictBool] = Field(default=None, description="True if the IP address is considered risky, based on multiple IP data points and velocity calculations.", alias="ipRisk")
    ip_risk_score: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Comprehensive risk score associated with an IP address, with a higher score indicating a riskier IP address. A number between 0 and 1 rounded to three decimal places.", alias="ipRiskScore")
    ip_last_seen_days: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Count of days since the IP address was last observed in Ekata's Identity Network. If the IP address has not been observed before, IpLastSeenDays will be 0.", alias="ipLastSeenDays")
    ip_geolocation_country_code: Optional[StrictStr] = Field(default=None, description="The ISO-3166 alpha-2 country code associated with the geolocation of the IP address.", alias="ipGeolocationCountryCode")
    ip_geolocation_subdivision: Optional[StrictStr] = Field(default=None, description="More granular detail about the IP address location.", alias="ipGeolocationSubdivision")
    ip_phone_distance: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The distance (in miles) between the IP address and the closest physical address associated with the phone number.", alias="ipPhoneDistance")
    ip_address_distance: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The distance (in miles) between the IP address and the physical address.", alias="ipAddressDistance")
    is_phone_valid: Optional[StrictBool] = Field(default=None, description="True if the phone number is valid.", alias="isPhoneValid")
    phone_line_type: Optional[StrictStr] = Field(default=None, description="The line type of the phone number. * landline - traditional wired phone line. * fixed-voip - VoIP-based fixed line phones. * mobile - wireless phone line. * voicemail - voicemail-only service. * toll-free - callee pays for call. * premium - caller pays a premium for the call-e.g., 976 area code. * non-fixed-voip - Skype, for example * other - anything that does not match the previous categories.", alias="phoneLineType")
    phone_carrier: Optional[StrictStr] = Field(default=None, description="The company that provides voice and/or data services for the phone number. Carriers are returned at the MVNO level.", alias="phoneCarrier")
    phone_country_code: Optional[StrictStr] = Field(default=None, description="The ISO-3166 alpha-2 country code associated with the phone number.", alias="phoneCountryCode")
    phone_last_seen_days: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Count of days since the phone was last observed in Ekata's Identity Network. If the phone has not been observed before, `phoneLastSeenDays` will be 0.", alias="phoneLastSeenDays")
    phone_email_first_seen_days: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Count of days since the combination of phone and email was first observed in Ekata's Identity Network. If that combination has not been observed before, `phoneEmailFirstSeenDays` will be 0.", alias="phoneEmailFirstSeenDays")
    phone_to_name: Optional[StrictStr] = Field(default=None, description="The match status between the input name and the queried entity.  * not-found  * match  * no-match", alias="phoneToName")
    phone_to_address: Optional[StrictStr] = Field(default=None, description="The match status between the input phone and the queried entity. * match - Phone location matches input address line 1, address line 2, city, state, and postal code.  * postal-match - Phone location postal code matches input address postal code.  * zip4-match - Phone location postal code zip+4 matches input address postal code zip+4.  * city-state-match - Phone location city and state matches input address city and state. * metro-match - Phone location is in the same metro area as input address.  * country-match - Phone location country matches input address country.  * no-match - Phone location does not match input address.", alias="phoneToAddress")
    address_validity_level: Optional[StrictStr] = Field(default=None, description="The most granular level to which the address could be validated. Ex. If the address was only valid to the city level (but not to the house level), it would return “valid_to_city”.   * missing_address - An input address was not provided.    * invalid - The input address is not valid.    * valid - The input address is valid.    * valid_to_country - The input address could only be validated to the country level. This means the country of the input address is valid, but the other elements of the input address were unable to be confirmed as valid or invalid.    * valid_to_city - The input address was validated to the city level. This means the country, state, city, and postal code of the input address are valid, but the street, house number, and subpremise of the input address were unable to be confirmed as valid or invalid.    * valid_to_street - The input address was validated to the street level. This means the country, state, city, postal code, and street of the input address are valid, but the house number and subpremise of the input address were unable to be confirmed as valid or invalid.      * valid_to_house_number - The input address was validated to the street and house number level. This means the country, state, city, postal code, street, and house number of the input address are valid, but the subpremise of the input address was unable to be confirmed as valid or invalid.      * valid_to_house_number_missing_apt - The input address was validated to the street and house number level. This means the country, state, city, postal code, street, and house number of the input address are valid, but the subpremise of the input address was missing and thus unable to be confirmed as valid or invalid.", alias="addressValidityLevel")
    address_to_name: Optional[StrictStr] = Field(default=None, description="The match status between the input name and the queried entity. * not-found * match * no-match", alias="addressToName")
    email_risk: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Email Risk Score assesses the risk level of an email address by leveraging features from our Identity Graph and Identity Network. It provides the strongest indicator of a high-risk email.", alias="emailRisk")
    identity_risk_score: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Comprehensive identity risk score with a higher score indicating a riskier account sign-up.", alias="identityRiskScore")
    device: Optional[DeviceInsights] = None
    warnings: Optional[List[StrictStr]] = None
    alerts: Optional[List[StrictStr]] = None
    __properties: ClassVar[List[str]] = ["requestRefId", "isEmailValid", "emailFirstSeenDays", "emailDomainCreationDate", "emailToName", "ipRisk", "ipRiskScore", "ipLastSeenDays", "ipGeolocationCountryCode", "ipGeolocationSubdivision", "ipPhoneDistance", "ipAddressDistance", "isPhoneValid", "phoneLineType", "phoneCarrier", "phoneCountryCode", "phoneLastSeenDays", "phoneEmailFirstSeenDays", "phoneToName", "phoneToAddress", "addressValidityLevel", "addressToName", "emailRisk", "identityRiskScore", "device", "warnings", "alerts"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountOwnerIdentityInsights from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of device
        if self.device:
            _dict['device'] = self.device.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountOwnerIdentityInsights from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "requestRefId": obj.get("requestRefId"),
            "isEmailValid": obj.get("isEmailValid"),
            "emailFirstSeenDays": obj.get("emailFirstSeenDays"),
            "emailDomainCreationDate": obj.get("emailDomainCreationDate"),
            "emailToName": obj.get("emailToName"),
            "ipRisk": obj.get("ipRisk"),
            "ipRiskScore": obj.get("ipRiskScore"),
            "ipLastSeenDays": obj.get("ipLastSeenDays"),
            "ipGeolocationCountryCode": obj.get("ipGeolocationCountryCode"),
            "ipGeolocationSubdivision": obj.get("ipGeolocationSubdivision"),
            "ipPhoneDistance": obj.get("ipPhoneDistance"),
            "ipAddressDistance": obj.get("ipAddressDistance"),
            "isPhoneValid": obj.get("isPhoneValid"),
            "phoneLineType": obj.get("phoneLineType"),
            "phoneCarrier": obj.get("phoneCarrier"),
            "phoneCountryCode": obj.get("phoneCountryCode"),
            "phoneLastSeenDays": obj.get("phoneLastSeenDays"),
            "phoneEmailFirstSeenDays": obj.get("phoneEmailFirstSeenDays"),
            "phoneToName": obj.get("phoneToName"),
            "phoneToAddress": obj.get("phoneToAddress"),
            "addressValidityLevel": obj.get("addressValidityLevel"),
            "addressToName": obj.get("addressToName"),
            "emailRisk": obj.get("emailRisk"),
            "identityRiskScore": obj.get("identityRiskScore"),
            "device": DeviceInsights.from_dict(obj["device"]) if obj.get("device") is not None else None,
            "warnings": obj.get("warnings"),
            "alerts": obj.get("alerts")
        })
        return _obj


