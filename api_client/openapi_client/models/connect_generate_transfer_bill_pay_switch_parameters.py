# coding: utf-8

"""
    Open Finance

    OpenAPI specification for Finicity APIs.  Open Finance (formerly Open Banking) solutions in the US are provided by Finicity, a Mastercard company.

    The version of the OpenAPI document: 1.31.2
    Contact: apisupport@mastercard.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.bill_pay_switch_identity import BillPaySwitchIdentity
from openapi_client.models.card import Card
from openapi_client.models.deposit_switch_account import DepositSwitchAccount
from openapi_client.models.service_agreement import ServiceAgreement
from typing import Optional, Set
from typing_extensions import Self

class ConnectGenerateTransferBillPaySwitchParameters(BaseModel):
    """
    ConnectGenerateTransferBillPaySwitchParameters
    """ # noqa: E501
    service_agreement: Optional[ServiceAgreement] = Field(default=None, alias="serviceAgreement")
    accounts: Optional[List[DepositSwitchAccount]] = Field(default=None, description="List of customer accounts (one or more) for Deposit Switch.")
    partner_id: StrictStr = Field(description="Your Partner ID displayed in the [Developer Dashboard](https://developer.mastercard.com/account/log-in)", alias="partnerId")
    customer_id: StrictStr = Field(description="A customer ID. See Add Customer API for how to create a customer ID.", alias="customerId")
    experience: Optional[StrictStr] = Field(default=None, description="The `experience` field allows you to customize:    * To toggle landing screen visibility    Note: the Finicity sales engineers (SE) help you set up a default   experience for your company. For each additional experience you create   thereafter, they'll give you a unique ID. See [Configure the Data Connect   Experience](https://developer.mastercard.com/open-banking-us/documentation/connect/configure-connect-experience/).     Experience values options:    * \"default\": your default experience (must be defined)   * GUID: the code for a different experience")
    language: Optional[StrictStr] = Field(default=None, description="By default, the Data Connect application is in English. You don't need to pass this parameter unless you want to translate Data Connect into one of our supported languages.  * Spanish (United States): `es` ")
    single_use_url: StrictBool = Field(description="\"true\": The URL link expires after a Data Connect session successfully completes.  Note: when the `singleUseUrl` and the `experience` parameters are passed in the same call, the `singleUseUrl` value overrides the `singleUseUrl` value configured in the `experience` parameter.", alias="singleUseUrl")
    redirect_uri: Optional[StrictStr] = Field(default=None, description="The URL that customers will be redirected to after completing Mastercard Data Connect.  Required unless Data Connect is embedded inside our application (iframe). Required for NON SDK integrations, should be iOS universal link OR Android app link when Data Connect is hosted in a web view / secure container of the partner mobile app.", alias="redirectUri")
    cards: Annotated[List[Card], Field(min_length=1)] = Field(description="List of the user cards. Mandatory when use case is BPS.")
    identity: BillPaySwitchIdentity
    __properties: ClassVar[List[str]] = ["serviceAgreement", "accounts", "partnerId", "customerId", "experience", "language", "singleUseUrl", "redirectUri", "cards", "identity"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ConnectGenerateTransferBillPaySwitchParameters from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of service_agreement
        if self.service_agreement:
            _dict['serviceAgreement'] = self.service_agreement.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in accounts (list)
        _items = []
        if self.accounts:
            for _item_accounts in self.accounts:
                if _item_accounts:
                    _items.append(_item_accounts.to_dict())
            _dict['accounts'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in cards (list)
        _items = []
        if self.cards:
            for _item_cards in self.cards:
                if _item_cards:
                    _items.append(_item_cards.to_dict())
            _dict['cards'] = _items
        # override the default output from pydantic by calling `to_dict()` of identity
        if self.identity:
            _dict['identity'] = self.identity.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ConnectGenerateTransferBillPaySwitchParameters from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "serviceAgreement": ServiceAgreement.from_dict(obj["serviceAgreement"]) if obj.get("serviceAgreement") is not None else None,
            "accounts": [DepositSwitchAccount.from_dict(_item) for _item in obj["accounts"]] if obj.get("accounts") is not None else None,
            "partnerId": obj.get("partnerId"),
            "customerId": obj.get("customerId"),
            "experience": obj.get("experience"),
            "language": obj.get("language"),
            "singleUseUrl": obj.get("singleUseUrl"),
            "redirectUri": obj.get("redirectUri"),
            "cards": [Card.from_dict(_item) for _item in obj["cards"]] if obj.get("cards") is not None else None,
            "identity": BillPaySwitchIdentity.from_dict(obj["identity"]) if obj.get("identity") is not None else None
        })
        return _obj


