# coding: utf-8

"""
    Open Finance

    OpenAPI specification for Finicity APIs.  Open Finance (formerly Open Banking) solutions in the US are provided by Finicity, a Mastercard company.

    The version of the OpenAPI document: 1.31.2
    Contact: apisupport@mastercard.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
from inspect import getfullargspec
import json
import pprint
import re  # noqa: F401
from pydantic import BaseModel, ConfigDict, Field, StrictStr, ValidationError, field_validator
from typing import Optional
from openapi_client.models.af_balance_analytics_report import AFBalanceAnalyticsReport
from openapi_client.models.af_cash_flow_analytics_report import AFCashFlowAnalyticsReport
from openapi_client.models.af_payment_history_analytics_report import AFPaymentHistoryAnalyticsReport
from openapi_client.models.cash_flow_report import CashFlowReport
from openapi_client.models.pay_statement_report import PayStatementReport
from openapi_client.models.prequalification_report import PrequalificationReport
from openapi_client.models.statement_report import StatementReport
from openapi_client.models.transactions_report import TransactionsReport
from openapi_client.models.voa_report import VOAReport
from openapi_client.models.voa_with_income_report import VOAWithIncomeReport
from openapi_client.models.voe_payroll_report import VOEPayrollReport
from openapi_client.models.voe_transactions_report import VOETransactionsReport
from openapi_client.models.voi_report import VOIReport
from openapi_client.models.voie_payroll_report import VOIEPayrollReport
from openapi_client.models.voie_paystub_report import VOIEPaystubReport
from openapi_client.models.voie_paystub_with_tx_verify_report import VOIEPaystubWithTXVerifyReport
from typing import Union, Any, List, Set, TYPE_CHECKING, Optional, Dict
from typing_extensions import Literal, Self
from pydantic import Field

REPORT_ANY_OF_SCHEMAS = ["AFBalanceAnalyticsReport", "AFCashFlowAnalyticsReport", "AFPaymentHistoryAnalyticsReport", "CashFlowReport", "PayStatementReport", "PrequalificationReport", "StatementReport", "TransactionsReport", "VOAReport", "VOAWithIncomeReport", "VOEPayrollReport", "VOETransactionsReport", "VOIEPayrollReport", "VOIEPaystubReport", "VOIEPaystubWithTXVerifyReport", "VOIReport"]

class Report(BaseModel):
    """
    A report
    """

    # data type: AFBalanceAnalyticsReport
    anyof_schema_1_validator: Optional[AFBalanceAnalyticsReport] = None
    # data type: AFCashFlowAnalyticsReport
    anyof_schema_2_validator: Optional[AFCashFlowAnalyticsReport] = None
    # data type: AFPaymentHistoryAnalyticsReport
    anyof_schema_3_validator: Optional[AFPaymentHistoryAnalyticsReport] = None
    # data type: CashFlowReport
    anyof_schema_4_validator: Optional[CashFlowReport] = None
    # data type: PrequalificationReport
    anyof_schema_5_validator: Optional[PrequalificationReport] = None
    # data type: PayStatementReport
    anyof_schema_6_validator: Optional[PayStatementReport] = None
    # data type: StatementReport
    anyof_schema_7_validator: Optional[StatementReport] = None
    # data type: TransactionsReport
    anyof_schema_8_validator: Optional[TransactionsReport] = None
    # data type: VOAReport
    anyof_schema_9_validator: Optional[VOAReport] = None
    # data type: VOAWithIncomeReport
    anyof_schema_10_validator: Optional[VOAWithIncomeReport] = None
    # data type: VOEPayrollReport
    anyof_schema_11_validator: Optional[VOEPayrollReport] = None
    # data type: VOETransactionsReport
    anyof_schema_12_validator: Optional[VOETransactionsReport] = None
    # data type: VOIReport
    anyof_schema_13_validator: Optional[VOIReport] = None
    # data type: VOIEPayrollReport
    anyof_schema_14_validator: Optional[VOIEPayrollReport] = None
    # data type: VOIEPaystubReport
    anyof_schema_15_validator: Optional[VOIEPaystubReport] = None
    # data type: VOIEPaystubWithTXVerifyReport
    anyof_schema_16_validator: Optional[VOIEPaystubWithTXVerifyReport] = None
    if TYPE_CHECKING:
        actual_instance: Optional[Union[AFBalanceAnalyticsReport, AFCashFlowAnalyticsReport, AFPaymentHistoryAnalyticsReport, CashFlowReport, PayStatementReport, PrequalificationReport, StatementReport, TransactionsReport, VOAReport, VOAWithIncomeReport, VOEPayrollReport, VOETransactionsReport, VOIEPayrollReport, VOIEPaystubReport, VOIEPaystubWithTXVerifyReport, VOIReport]] = None
    else:
        actual_instance: Any = None
    any_of_schemas: Set[str] = { "AFBalanceAnalyticsReport", "AFCashFlowAnalyticsReport", "AFPaymentHistoryAnalyticsReport", "CashFlowReport", "PayStatementReport", "PrequalificationReport", "StatementReport", "TransactionsReport", "VOAReport", "VOAWithIncomeReport", "VOEPayrollReport", "VOETransactionsReport", "VOIEPayrollReport", "VOIEPaystubReport", "VOIEPaystubWithTXVerifyReport", "VOIReport" }

    model_config = {
        "validate_assignment": True,
        "protected_namespaces": (),
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_anyof(cls, v):
        instance = Report.model_construct()
        error_messages = []
        # validate data type: AFBalanceAnalyticsReport
        if not isinstance(v, AFBalanceAnalyticsReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AFBalanceAnalyticsReport`")
        else:
            return v

        # validate data type: AFCashFlowAnalyticsReport
        if not isinstance(v, AFCashFlowAnalyticsReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AFCashFlowAnalyticsReport`")
        else:
            return v

        # validate data type: AFPaymentHistoryAnalyticsReport
        if not isinstance(v, AFPaymentHistoryAnalyticsReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AFPaymentHistoryAnalyticsReport`")
        else:
            return v

        # validate data type: CashFlowReport
        if not isinstance(v, CashFlowReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `CashFlowReport`")
        else:
            return v

        # validate data type: PrequalificationReport
        if not isinstance(v, PrequalificationReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `PrequalificationReport`")
        else:
            return v

        # validate data type: PayStatementReport
        if not isinstance(v, PayStatementReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `PayStatementReport`")
        else:
            return v

        # validate data type: StatementReport
        if not isinstance(v, StatementReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `StatementReport`")
        else:
            return v

        # validate data type: TransactionsReport
        if not isinstance(v, TransactionsReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `TransactionsReport`")
        else:
            return v

        # validate data type: VOAReport
        if not isinstance(v, VOAReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `VOAReport`")
        else:
            return v

        # validate data type: VOAWithIncomeReport
        if not isinstance(v, VOAWithIncomeReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `VOAWithIncomeReport`")
        else:
            return v

        # validate data type: VOEPayrollReport
        if not isinstance(v, VOEPayrollReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `VOEPayrollReport`")
        else:
            return v

        # validate data type: VOETransactionsReport
        if not isinstance(v, VOETransactionsReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `VOETransactionsReport`")
        else:
            return v

        # validate data type: VOIReport
        if not isinstance(v, VOIReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `VOIReport`")
        else:
            return v

        # validate data type: VOIEPayrollReport
        if not isinstance(v, VOIEPayrollReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `VOIEPayrollReport`")
        else:
            return v

        # validate data type: VOIEPaystubReport
        if not isinstance(v, VOIEPaystubReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `VOIEPaystubReport`")
        else:
            return v

        # validate data type: VOIEPaystubWithTXVerifyReport
        if not isinstance(v, VOIEPaystubWithTXVerifyReport):
            error_messages.append(f"Error! Input type `{type(v)}` is not `VOIEPaystubWithTXVerifyReport`")
        else:
            return v

        if error_messages:
            # no match
            raise ValueError("No match found when setting the actual_instance in Report with anyOf schemas: AFBalanceAnalyticsReport, AFCashFlowAnalyticsReport, AFPaymentHistoryAnalyticsReport, CashFlowReport, PayStatementReport, PrequalificationReport, StatementReport, TransactionsReport, VOAReport, VOAWithIncomeReport, VOEPayrollReport, VOETransactionsReport, VOIEPayrollReport, VOIEPaystubReport, VOIEPaystubWithTXVerifyReport, VOIReport. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: Dict[str, Any]) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        # anyof_schema_1_validator: Optional[AFBalanceAnalyticsReport] = None
        try:
            instance.actual_instance = AFBalanceAnalyticsReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_2_validator: Optional[AFCashFlowAnalyticsReport] = None
        try:
            instance.actual_instance = AFCashFlowAnalyticsReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_3_validator: Optional[AFPaymentHistoryAnalyticsReport] = None
        try:
            instance.actual_instance = AFPaymentHistoryAnalyticsReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_4_validator: Optional[CashFlowReport] = None
        try:
            instance.actual_instance = CashFlowReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_5_validator: Optional[PrequalificationReport] = None
        try:
            instance.actual_instance = PrequalificationReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_6_validator: Optional[PayStatementReport] = None
        try:
            instance.actual_instance = PayStatementReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_7_validator: Optional[StatementReport] = None
        try:
            instance.actual_instance = StatementReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_8_validator: Optional[TransactionsReport] = None
        try:
            instance.actual_instance = TransactionsReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_9_validator: Optional[VOAReport] = None
        try:
            instance.actual_instance = VOAReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_10_validator: Optional[VOAWithIncomeReport] = None
        try:
            instance.actual_instance = VOAWithIncomeReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_11_validator: Optional[VOEPayrollReport] = None
        try:
            instance.actual_instance = VOEPayrollReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_12_validator: Optional[VOETransactionsReport] = None
        try:
            instance.actual_instance = VOETransactionsReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_13_validator: Optional[VOIReport] = None
        try:
            instance.actual_instance = VOIReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_14_validator: Optional[VOIEPayrollReport] = None
        try:
            instance.actual_instance = VOIEPayrollReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_15_validator: Optional[VOIEPaystubReport] = None
        try:
            instance.actual_instance = VOIEPaystubReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
        # anyof_schema_16_validator: Optional[VOIEPaystubWithTXVerifyReport] = None
        try:
            instance.actual_instance = VOIEPaystubWithTXVerifyReport.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))

        if error_messages:
            # no match
            raise ValueError("No match found when deserializing the JSON string into Report with anyOf schemas: AFBalanceAnalyticsReport, AFCashFlowAnalyticsReport, AFPaymentHistoryAnalyticsReport, CashFlowReport, PayStatementReport, PrequalificationReport, StatementReport, TransactionsReport, VOAReport, VOAWithIncomeReport, VOEPayrollReport, VOETransactionsReport, VOIEPayrollReport, VOIEPaystubReport, VOIEPaystubWithTXVerifyReport, VOIReport. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        if hasattr(self.actual_instance, "to_json") and callable(self.actual_instance.to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Optional[Union[Dict[str, Any], AFBalanceAnalyticsReport, AFCashFlowAnalyticsReport, AFPaymentHistoryAnalyticsReport, CashFlowReport, PayStatementReport, PrequalificationReport, StatementReport, TransactionsReport, VOAReport, VOAWithIncomeReport, VOEPayrollReport, VOETransactionsReport, VOIEPayrollReport, VOIEPaystubReport, VOIEPaystubWithTXVerifyReport, VOIReport]]:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        if hasattr(self.actual_instance, "to_dict") and callable(self.actual_instance.to_dict):
            return self.actual_instance.to_dict()
        else:
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())


