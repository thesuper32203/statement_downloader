# coding: utf-8

"""
    Open Finance

    OpenAPI specification for Finicity APIs.  Open Finance (formerly Open Banking) solutions in the US are provided by Finicity, a Mastercard company.

    The version of the OpenAPI document: 1.31.2
    Contact: apisupport@mastercard.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.transaction import Transaction
from openapi_client.models.transactions import Transactions
from openapi_client.models.transactions_report_ack import TransactionsReportAck
from openapi_client.models.transactions_report_constraints import TransactionsReportConstraints

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class TransactionsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def generate_transactions_report(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        transactions_report_constraints: TransactionsReportConstraints,
        callback_url: Annotated[Optional[StrictStr], Field(description="A Report Listener URL to receive notifications. The webhook must respond to the Finicity API with a 2xx HTTP status code.")] = None,
        from_date: Annotated[Optional[StrictInt], Field(description="Transactions starting from this date will be included in the report.")] = None,
        to_date: Annotated[Optional[StrictInt], Field(description="Transactions up to and including this date will be incorporated into the report. It should be later than the fromDate.")] = None,
        include_pending: Annotated[Optional[StrictBool], Field(description="If pending transactions must be included")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TransactionsReportAck:
        """Generate Transactions Report for the customer

        Generate a Transaction Report for the given accounts under the given customer. This service retrieves up to 24 months of transaction history for the given customer. It then uses this information to generate the Transaction Report.  This is a premium service. A billable event will be created upon the successful generation of the Transactions Report.  Before calling this API, a consumer must be created for the given customer ID (see Consumers APIs).  There cannot be more than 24 months between `fromDate` and `toDate`.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param transactions_report_constraints: (required)
        :type transactions_report_constraints: TransactionsReportConstraints
        :param callback_url: A Report Listener URL to receive notifications. The webhook must respond to the Finicity API with a 2xx HTTP status code.
        :type callback_url: str
        :param from_date: Transactions starting from this date will be included in the report.
        :type from_date: int
        :param to_date: Transactions up to and including this date will be incorporated into the report. It should be later than the fromDate.
        :type to_date: int
        :param include_pending: If pending transactions must be included
        :type include_pending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._generate_transactions_report_serialize(
            customer_id=customer_id,
            transactions_report_constraints=transactions_report_constraints,
            callback_url=callback_url,
            from_date=from_date,
            to_date=to_date,
            include_pending=include_pending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "TransactionsReportAck",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '403': "SecurityFreezeErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def generate_transactions_report_with_http_info(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        transactions_report_constraints: TransactionsReportConstraints,
        callback_url: Annotated[Optional[StrictStr], Field(description="A Report Listener URL to receive notifications. The webhook must respond to the Finicity API with a 2xx HTTP status code.")] = None,
        from_date: Annotated[Optional[StrictInt], Field(description="Transactions starting from this date will be included in the report.")] = None,
        to_date: Annotated[Optional[StrictInt], Field(description="Transactions up to and including this date will be incorporated into the report. It should be later than the fromDate.")] = None,
        include_pending: Annotated[Optional[StrictBool], Field(description="If pending transactions must be included")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TransactionsReportAck]:
        """Generate Transactions Report for the customer

        Generate a Transaction Report for the given accounts under the given customer. This service retrieves up to 24 months of transaction history for the given customer. It then uses this information to generate the Transaction Report.  This is a premium service. A billable event will be created upon the successful generation of the Transactions Report.  Before calling this API, a consumer must be created for the given customer ID (see Consumers APIs).  There cannot be more than 24 months between `fromDate` and `toDate`.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param transactions_report_constraints: (required)
        :type transactions_report_constraints: TransactionsReportConstraints
        :param callback_url: A Report Listener URL to receive notifications. The webhook must respond to the Finicity API with a 2xx HTTP status code.
        :type callback_url: str
        :param from_date: Transactions starting from this date will be included in the report.
        :type from_date: int
        :param to_date: Transactions up to and including this date will be incorporated into the report. It should be later than the fromDate.
        :type to_date: int
        :param include_pending: If pending transactions must be included
        :type include_pending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._generate_transactions_report_serialize(
            customer_id=customer_id,
            transactions_report_constraints=transactions_report_constraints,
            callback_url=callback_url,
            from_date=from_date,
            to_date=to_date,
            include_pending=include_pending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "TransactionsReportAck",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '403': "SecurityFreezeErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def generate_transactions_report_without_preload_content(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        transactions_report_constraints: TransactionsReportConstraints,
        callback_url: Annotated[Optional[StrictStr], Field(description="A Report Listener URL to receive notifications. The webhook must respond to the Finicity API with a 2xx HTTP status code.")] = None,
        from_date: Annotated[Optional[StrictInt], Field(description="Transactions starting from this date will be included in the report.")] = None,
        to_date: Annotated[Optional[StrictInt], Field(description="Transactions up to and including this date will be incorporated into the report. It should be later than the fromDate.")] = None,
        include_pending: Annotated[Optional[StrictBool], Field(description="If pending transactions must be included")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Generate Transactions Report for the customer

        Generate a Transaction Report for the given accounts under the given customer. This service retrieves up to 24 months of transaction history for the given customer. It then uses this information to generate the Transaction Report.  This is a premium service. A billable event will be created upon the successful generation of the Transactions Report.  Before calling this API, a consumer must be created for the given customer ID (see Consumers APIs).  There cannot be more than 24 months between `fromDate` and `toDate`.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param transactions_report_constraints: (required)
        :type transactions_report_constraints: TransactionsReportConstraints
        :param callback_url: A Report Listener URL to receive notifications. The webhook must respond to the Finicity API with a 2xx HTTP status code.
        :type callback_url: str
        :param from_date: Transactions starting from this date will be included in the report.
        :type from_date: int
        :param to_date: Transactions up to and including this date will be incorporated into the report. It should be later than the fromDate.
        :type to_date: int
        :param include_pending: If pending transactions must be included
        :type include_pending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._generate_transactions_report_serialize(
            customer_id=customer_id,
            transactions_report_constraints=transactions_report_constraints,
            callback_url=callback_url,
            from_date=from_date,
            to_date=to_date,
            include_pending=include_pending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "TransactionsReportAck",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '403': "SecurityFreezeErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _generate_transactions_report_serialize(
        self,
        customer_id,
        transactions_report_constraints,
        callback_url,
        from_date,
        to_date,
        include_pending,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if customer_id is not None:
            _path_params['customerId'] = customer_id
        # process the query parameters
        if callback_url is not None:
            
            _query_params.append(('callbackUrl', callback_url))
            
        if from_date is not None:
            
            _query_params.append(('fromDate', from_date))
            
        if to_date is not None:
            
            _query_params.append(('toDate', to_date))
            
        if include_pending is not None:
            
            _query_params.append(('includePending', include_pending))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if transactions_report_constraints is not None:
            _body_params = transactions_report_constraints


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/decisioning/v2/customers/{customerId}/transactions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_all_customer_transactions(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        from_date: Annotated[StrictInt, Field(description="A start date")],
        to_date: Annotated[StrictInt, Field(description="A end date")],
        start: Annotated[Optional[StrictInt], Field(description="Index of the page of results to return")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Maximum number of results per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Date sort order: \"asc\" for ascending, \"desc\" for descending")] = None,
        include_pending: Annotated[Optional[StrictBool], Field(description="If pending transactions must be included")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Transactions:
        """Get All Customer Transactions

        Get all transactions available for this customer within the given date range, across all accounts. This service supports paging and sorting by `transactionDate` (or `postedDate` if no transaction date is provided), with a maximum of 1000 transactions per request.  Standard consumer aggregation provides up to 180 days of transactions prior to the date each account was added to the Finicity system. To access older transactions, you must first call the service Load Historic Transactions for Account.  There is no limit for the size of the window between `fromDate` and `toDate`, however, the maximum number of transactions returned on one page is 1000.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param from_date: A start date (required)
        :type from_date: int
        :param to_date: A end date (required)
        :type to_date: int
        :param start: Index of the page of results to return
        :type start: int
        :param limit: Maximum number of results per page
        :type limit: int
        :param sort: Date sort order: \"asc\" for ascending, \"desc\" for descending
        :type sort: str
        :param include_pending: If pending transactions must be included
        :type include_pending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_customer_transactions_serialize(
            customer_id=customer_id,
            from_date=from_date,
            to_date=to_date,
            start=start,
            limit=limit,
            sort=sort,
            include_pending=include_pending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transactions",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_all_customer_transactions_with_http_info(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        from_date: Annotated[StrictInt, Field(description="A start date")],
        to_date: Annotated[StrictInt, Field(description="A end date")],
        start: Annotated[Optional[StrictInt], Field(description="Index of the page of results to return")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Maximum number of results per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Date sort order: \"asc\" for ascending, \"desc\" for descending")] = None,
        include_pending: Annotated[Optional[StrictBool], Field(description="If pending transactions must be included")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Transactions]:
        """Get All Customer Transactions

        Get all transactions available for this customer within the given date range, across all accounts. This service supports paging and sorting by `transactionDate` (or `postedDate` if no transaction date is provided), with a maximum of 1000 transactions per request.  Standard consumer aggregation provides up to 180 days of transactions prior to the date each account was added to the Finicity system. To access older transactions, you must first call the service Load Historic Transactions for Account.  There is no limit for the size of the window between `fromDate` and `toDate`, however, the maximum number of transactions returned on one page is 1000.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param from_date: A start date (required)
        :type from_date: int
        :param to_date: A end date (required)
        :type to_date: int
        :param start: Index of the page of results to return
        :type start: int
        :param limit: Maximum number of results per page
        :type limit: int
        :param sort: Date sort order: \"asc\" for ascending, \"desc\" for descending
        :type sort: str
        :param include_pending: If pending transactions must be included
        :type include_pending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_customer_transactions_serialize(
            customer_id=customer_id,
            from_date=from_date,
            to_date=to_date,
            start=start,
            limit=limit,
            sort=sort,
            include_pending=include_pending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transactions",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_all_customer_transactions_without_preload_content(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        from_date: Annotated[StrictInt, Field(description="A start date")],
        to_date: Annotated[StrictInt, Field(description="A end date")],
        start: Annotated[Optional[StrictInt], Field(description="Index of the page of results to return")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Maximum number of results per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Date sort order: \"asc\" for ascending, \"desc\" for descending")] = None,
        include_pending: Annotated[Optional[StrictBool], Field(description="If pending transactions must be included")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get All Customer Transactions

        Get all transactions available for this customer within the given date range, across all accounts. This service supports paging and sorting by `transactionDate` (or `postedDate` if no transaction date is provided), with a maximum of 1000 transactions per request.  Standard consumer aggregation provides up to 180 days of transactions prior to the date each account was added to the Finicity system. To access older transactions, you must first call the service Load Historic Transactions for Account.  There is no limit for the size of the window between `fromDate` and `toDate`, however, the maximum number of transactions returned on one page is 1000.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param from_date: A start date (required)
        :type from_date: int
        :param to_date: A end date (required)
        :type to_date: int
        :param start: Index of the page of results to return
        :type start: int
        :param limit: Maximum number of results per page
        :type limit: int
        :param sort: Date sort order: \"asc\" for ascending, \"desc\" for descending
        :type sort: str
        :param include_pending: If pending transactions must be included
        :type include_pending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_customer_transactions_serialize(
            customer_id=customer_id,
            from_date=from_date,
            to_date=to_date,
            start=start,
            limit=limit,
            sort=sort,
            include_pending=include_pending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transactions",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_all_customer_transactions_serialize(
        self,
        customer_id,
        from_date,
        to_date,
        start,
        limit,
        sort,
        include_pending,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if customer_id is not None:
            _path_params['customerId'] = customer_id
        # process the query parameters
        if from_date is not None:
            
            _query_params.append(('fromDate', from_date))
            
        if to_date is not None:
            
            _query_params.append(('toDate', to_date))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if include_pending is not None:
            
            _query_params.append(('includePending', include_pending))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/aggregation/v3/customers/{customerId}/transactions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_customer_account_transactions(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        account_id: Annotated[StrictStr, Field(description="The account ID")],
        from_date: Annotated[StrictInt, Field(description="A start date")],
        to_date: Annotated[StrictInt, Field(description="A end date")],
        start: Annotated[Optional[StrictInt], Field(description="Index of the page of results to return")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Maximum number of results per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Date sort order: \"asc\" for ascending, \"desc\" for descending")] = None,
        include_pending: Annotated[Optional[StrictBool], Field(description="If pending transactions must be included")] = None,
        show_daily_balance: Annotated[Optional[StrictBool], Field(description="Request daily beginning and ending account balances for each day transactions are recorded (query parameter)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Transactions:
        """Get Customer Account Transactions

        Get all transactions available for this customer account within the given date range. This service supports paging and sorting by `transactionDate` (or `postedDate` if no transaction date is provided), with a maximum of 1000 transactions per request.  Standard consumer aggregation provides up to 180 days of transactions prior to the date each account was added to the Finicity system. To access older transactions, you must first call the Cash Flow Verification service Load Historic Transactions for Account.  There is no limit for the size of the window between `fromDate` and `toDate`, however, the maximum number of transactions returned on one page is 1000.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param account_id: The account ID (required)
        :type account_id: str
        :param from_date: A start date (required)
        :type from_date: int
        :param to_date: A end date (required)
        :type to_date: int
        :param start: Index of the page of results to return
        :type start: int
        :param limit: Maximum number of results per page
        :type limit: int
        :param sort: Date sort order: \"asc\" for ascending, \"desc\" for descending
        :type sort: str
        :param include_pending: If pending transactions must be included
        :type include_pending: bool
        :param show_daily_balance: Request daily beginning and ending account balances for each day transactions are recorded (query parameter)
        :type show_daily_balance: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_customer_account_transactions_serialize(
            customer_id=customer_id,
            account_id=account_id,
            from_date=from_date,
            to_date=to_date,
            start=start,
            limit=limit,
            sort=sort,
            include_pending=include_pending,
            show_daily_balance=show_daily_balance,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transactions",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_customer_account_transactions_with_http_info(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        account_id: Annotated[StrictStr, Field(description="The account ID")],
        from_date: Annotated[StrictInt, Field(description="A start date")],
        to_date: Annotated[StrictInt, Field(description="A end date")],
        start: Annotated[Optional[StrictInt], Field(description="Index of the page of results to return")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Maximum number of results per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Date sort order: \"asc\" for ascending, \"desc\" for descending")] = None,
        include_pending: Annotated[Optional[StrictBool], Field(description="If pending transactions must be included")] = None,
        show_daily_balance: Annotated[Optional[StrictBool], Field(description="Request daily beginning and ending account balances for each day transactions are recorded (query parameter)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Transactions]:
        """Get Customer Account Transactions

        Get all transactions available for this customer account within the given date range. This service supports paging and sorting by `transactionDate` (or `postedDate` if no transaction date is provided), with a maximum of 1000 transactions per request.  Standard consumer aggregation provides up to 180 days of transactions prior to the date each account was added to the Finicity system. To access older transactions, you must first call the Cash Flow Verification service Load Historic Transactions for Account.  There is no limit for the size of the window between `fromDate` and `toDate`, however, the maximum number of transactions returned on one page is 1000.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param account_id: The account ID (required)
        :type account_id: str
        :param from_date: A start date (required)
        :type from_date: int
        :param to_date: A end date (required)
        :type to_date: int
        :param start: Index of the page of results to return
        :type start: int
        :param limit: Maximum number of results per page
        :type limit: int
        :param sort: Date sort order: \"asc\" for ascending, \"desc\" for descending
        :type sort: str
        :param include_pending: If pending transactions must be included
        :type include_pending: bool
        :param show_daily_balance: Request daily beginning and ending account balances for each day transactions are recorded (query parameter)
        :type show_daily_balance: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_customer_account_transactions_serialize(
            customer_id=customer_id,
            account_id=account_id,
            from_date=from_date,
            to_date=to_date,
            start=start,
            limit=limit,
            sort=sort,
            include_pending=include_pending,
            show_daily_balance=show_daily_balance,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transactions",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_customer_account_transactions_without_preload_content(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        account_id: Annotated[StrictStr, Field(description="The account ID")],
        from_date: Annotated[StrictInt, Field(description="A start date")],
        to_date: Annotated[StrictInt, Field(description="A end date")],
        start: Annotated[Optional[StrictInt], Field(description="Index of the page of results to return")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True)]], Field(description="Maximum number of results per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Date sort order: \"asc\" for ascending, \"desc\" for descending")] = None,
        include_pending: Annotated[Optional[StrictBool], Field(description="If pending transactions must be included")] = None,
        show_daily_balance: Annotated[Optional[StrictBool], Field(description="Request daily beginning and ending account balances for each day transactions are recorded (query parameter)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Customer Account Transactions

        Get all transactions available for this customer account within the given date range. This service supports paging and sorting by `transactionDate` (or `postedDate` if no transaction date is provided), with a maximum of 1000 transactions per request.  Standard consumer aggregation provides up to 180 days of transactions prior to the date each account was added to the Finicity system. To access older transactions, you must first call the Cash Flow Verification service Load Historic Transactions for Account.  There is no limit for the size of the window between `fromDate` and `toDate`, however, the maximum number of transactions returned on one page is 1000.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param account_id: The account ID (required)
        :type account_id: str
        :param from_date: A start date (required)
        :type from_date: int
        :param to_date: A end date (required)
        :type to_date: int
        :param start: Index of the page of results to return
        :type start: int
        :param limit: Maximum number of results per page
        :type limit: int
        :param sort: Date sort order: \"asc\" for ascending, \"desc\" for descending
        :type sort: str
        :param include_pending: If pending transactions must be included
        :type include_pending: bool
        :param show_daily_balance: Request daily beginning and ending account balances for each day transactions are recorded (query parameter)
        :type show_daily_balance: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_customer_account_transactions_serialize(
            customer_id=customer_id,
            account_id=account_id,
            from_date=from_date,
            to_date=to_date,
            start=start,
            limit=limit,
            sort=sort,
            include_pending=include_pending,
            show_daily_balance=show_daily_balance,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transactions",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_customer_account_transactions_serialize(
        self,
        customer_id,
        account_id,
        from_date,
        to_date,
        start,
        limit,
        sort,
        include_pending,
        show_daily_balance,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if customer_id is not None:
            _path_params['customerId'] = customer_id
        if account_id is not None:
            _path_params['accountId'] = account_id
        # process the query parameters
        if from_date is not None:
            
            _query_params.append(('fromDate', from_date))
            
        if to_date is not None:
            
            _query_params.append(('toDate', to_date))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if include_pending is not None:
            
            _query_params.append(('includePending', include_pending))
            
        if show_daily_balance is not None:
            
            _query_params.append(('showDailyBalance', show_daily_balance))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/aggregation/v4/customers/{customerId}/accounts/{accountId}/transactions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_customer_transaction(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        transaction_id: Annotated[StrictInt, Field(description="A transaction ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Transaction:
        """Get Customer Transaction by ID

        Get details for the given transaction.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param transaction_id: A transaction ID (required)
        :type transaction_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_customer_transaction_serialize(
            customer_id=customer_id,
            transaction_id=transaction_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transaction",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_customer_transaction_with_http_info(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        transaction_id: Annotated[StrictInt, Field(description="A transaction ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Transaction]:
        """Get Customer Transaction by ID

        Get details for the given transaction.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param transaction_id: A transaction ID (required)
        :type transaction_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_customer_transaction_serialize(
            customer_id=customer_id,
            transaction_id=transaction_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transaction",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_customer_transaction_without_preload_content(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        transaction_id: Annotated[StrictInt, Field(description="A transaction ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Customer Transaction by ID

        Get details for the given transaction.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param transaction_id: A transaction ID (required)
        :type transaction_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_customer_transaction_serialize(
            customer_id=customer_id,
            transaction_id=transaction_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transaction",
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_customer_transaction_serialize(
        self,
        customer_id,
        transaction_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if customer_id is not None:
            _path_params['customerId'] = customer_id
        if transaction_id is not None:
            _path_params['transactionId'] = transaction_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/aggregation/v2/customers/{customerId}/transactions/{transactionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def load_historic_transactions_for_customer_account(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        account_id: Annotated[StrictStr, Field(description="The account ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Load Historic Transactions for Customer Account

        Connect to the account's financial institution and load up to 24 months of historic transactions for the account. Length of history varies by institution.  This is a premium service. The billable event is a call to this service specifying a customer ID that has not been seen before by this service. (If this service is called multiple times with the same customer ID, to load transactions from multiple accounts, only one billable event has occurred.)  The recommended timeout setting for this request is 180 seconds in order to receive a response. However, you can terminate the connection after making the call the operation will still complete. You will have to pull the account records to check for an updated aggregation attempt date to know when the refresh is complete.  The date range sent to the institution is calculated from the account's `createdDate`. This means that calling this service a second time for the same account normally will not add any new transactions for the account. For this reason, a second call to this service for a known account ID will usually return immediately.  In a few specific scenarios, it may be desirable to force a second connection to the institution for a known account ID. Some examples are:  * The institution's policy has changed, making more transactions available * Finicity has now added a longer transaction history support for the institution * The first call encountered an error, and the resulting Aggregation Ticket has now been fixed by the Finicity Support Team  In these cases, the POST request can contain the parameter `force=true` in the request body to force the second connection.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param account_id: The account ID (required)
        :type account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._load_historic_transactions_for_customer_account_serialize(
            customer_id=customer_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '203': None,
            '204': None,
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def load_historic_transactions_for_customer_account_with_http_info(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        account_id: Annotated[StrictStr, Field(description="The account ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Load Historic Transactions for Customer Account

        Connect to the account's financial institution and load up to 24 months of historic transactions for the account. Length of history varies by institution.  This is a premium service. The billable event is a call to this service specifying a customer ID that has not been seen before by this service. (If this service is called multiple times with the same customer ID, to load transactions from multiple accounts, only one billable event has occurred.)  The recommended timeout setting for this request is 180 seconds in order to receive a response. However, you can terminate the connection after making the call the operation will still complete. You will have to pull the account records to check for an updated aggregation attempt date to know when the refresh is complete.  The date range sent to the institution is calculated from the account's `createdDate`. This means that calling this service a second time for the same account normally will not add any new transactions for the account. For this reason, a second call to this service for a known account ID will usually return immediately.  In a few specific scenarios, it may be desirable to force a second connection to the institution for a known account ID. Some examples are:  * The institution's policy has changed, making more transactions available * Finicity has now added a longer transaction history support for the institution * The first call encountered an error, and the resulting Aggregation Ticket has now been fixed by the Finicity Support Team  In these cases, the POST request can contain the parameter `force=true` in the request body to force the second connection.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param account_id: The account ID (required)
        :type account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._load_historic_transactions_for_customer_account_serialize(
            customer_id=customer_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '203': None,
            '204': None,
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def load_historic_transactions_for_customer_account_without_preload_content(
        self,
        customer_id: Annotated[StrictStr, Field(description="A customer ID")],
        account_id: Annotated[StrictStr, Field(description="The account ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Load Historic Transactions for Customer Account

        Connect to the account's financial institution and load up to 24 months of historic transactions for the account. Length of history varies by institution.  This is a premium service. The billable event is a call to this service specifying a customer ID that has not been seen before by this service. (If this service is called multiple times with the same customer ID, to load transactions from multiple accounts, only one billable event has occurred.)  The recommended timeout setting for this request is 180 seconds in order to receive a response. However, you can terminate the connection after making the call the operation will still complete. You will have to pull the account records to check for an updated aggregation attempt date to know when the refresh is complete.  The date range sent to the institution is calculated from the account's `createdDate`. This means that calling this service a second time for the same account normally will not add any new transactions for the account. For this reason, a second call to this service for a known account ID will usually return immediately.  In a few specific scenarios, it may be desirable to force a second connection to the institution for a known account ID. Some examples are:  * The institution's policy has changed, making more transactions available * Finicity has now added a longer transaction history support for the institution * The first call encountered an error, and the resulting Aggregation Ticket has now been fixed by the Finicity Support Team  In these cases, the POST request can contain the parameter `force=true` in the request body to force the second connection.  _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param customer_id: A customer ID (required)
        :type customer_id: str
        :param account_id: The account ID (required)
        :type account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._load_historic_transactions_for_customer_account_serialize(
            customer_id=customer_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '203': None,
            '204': None,
            '400': "ErrorMessage",
            '401': "ErrorMessage",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _load_historic_transactions_for_customer_account_serialize(
        self,
        customer_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if customer_id is not None:
            _path_params['customerId'] = customer_id
        if account_id is not None:
            _path_params['accountId'] = account_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/aggregation/v1/customers/{customerId}/accounts/{accountId}/transactions/historic',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


