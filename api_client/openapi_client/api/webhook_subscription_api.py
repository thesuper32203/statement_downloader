# coding: utf-8

"""
    Open Finance

    OpenAPI specification for Finicity APIs.  Open Finance (formerly Open Banking) solutions in the US are provided by Finicity, a Mastercard company.

    The version of the OpenAPI document: 1.31.2
    Contact: apisupport@mastercard.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.event_status_update import EventStatusUpdate
from openapi_client.models.list_available_webhook_subscription_events200_response import ListAvailableWebhookSubscriptionEvents200Response
from openapi_client.models.subscription import Subscription
from openapi_client.models.subscription_detail import SubscriptionDetail
from openapi_client.models.subscriptions import Subscriptions
from openapi_client.models.webhook_event import WebhookEvent

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class WebhookSubscriptionApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def change_webhook_subscription_event_status(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        event_status_update: Annotated[EventStatusUpdate, Field(description="Request body to an event active or inactive.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EventStatusUpdate:
        """Enable or disable Webhook Subscription Event

        Enables or disables a specific webhook event within a subscription identified by subscription ID and webhook event ID. Update the event's status to either active or inactive.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param event_status_update: Request body to an event active or inactive. (required)
        :type event_status_update: EventStatusUpdate
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_webhook_subscription_event_status_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            event_status_update=event_status_update,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventStatusUpdate",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def change_webhook_subscription_event_status_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        event_status_update: Annotated[EventStatusUpdate, Field(description="Request body to an event active or inactive.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EventStatusUpdate]:
        """Enable or disable Webhook Subscription Event

        Enables or disables a specific webhook event within a subscription identified by subscription ID and webhook event ID. Update the event's status to either active or inactive.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param event_status_update: Request body to an event active or inactive. (required)
        :type event_status_update: EventStatusUpdate
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_webhook_subscription_event_status_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            event_status_update=event_status_update,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventStatusUpdate",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def change_webhook_subscription_event_status_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        event_status_update: Annotated[EventStatusUpdate, Field(description="Request body to an event active or inactive.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Enable or disable Webhook Subscription Event

        Enables or disables a specific webhook event within a subscription identified by subscription ID and webhook event ID. Update the event's status to either active or inactive.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param event_status_update: Request body to an event active or inactive. (required)
        :type event_status_update: EventStatusUpdate
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_webhook_subscription_event_status_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            event_status_update=event_status_update,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventStatusUpdate",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _change_webhook_subscription_event_status_serialize(
        self,
        subscription_id,
        webhook_event_id,
        event_status_update,
        x_external_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscription_id'] = subscription_id
        if webhook_event_id is not None:
            _path_params['webhook_event_id'] = webhook_event_id
        # process the query parameters
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter
        if event_status_update is not None:
            _body_params = event_status_update


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/notification-subscriptions/webhooks/{subscription_id}/events/{webhook_event_id}/status',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def change_webhook_subscription_status(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        event_status_update: Annotated[EventStatusUpdate, Field(description="Request body to an event active or inactive.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EventStatusUpdate:
        """Enable or disable all the webhook event under a given webhook subscription

        Enables or disables all webhook subscription event for partner. Update the  status to either active or inactive. _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param event_status_update: Request body to an event active or inactive. (required)
        :type event_status_update: EventStatusUpdate
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_webhook_subscription_status_serialize(
            subscription_id=subscription_id,
            event_status_update=event_status_update,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventStatusUpdate",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def change_webhook_subscription_status_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        event_status_update: Annotated[EventStatusUpdate, Field(description="Request body to an event active or inactive.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EventStatusUpdate]:
        """Enable or disable all the webhook event under a given webhook subscription

        Enables or disables all webhook subscription event for partner. Update the  status to either active or inactive. _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param event_status_update: Request body to an event active or inactive. (required)
        :type event_status_update: EventStatusUpdate
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_webhook_subscription_status_serialize(
            subscription_id=subscription_id,
            event_status_update=event_status_update,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventStatusUpdate",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def change_webhook_subscription_status_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        event_status_update: Annotated[EventStatusUpdate, Field(description="Request body to an event active or inactive.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Enable or disable all the webhook event under a given webhook subscription

        Enables or disables all webhook subscription event for partner. Update the  status to either active or inactive. _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param event_status_update: Request body to an event active or inactive. (required)
        :type event_status_update: EventStatusUpdate
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_webhook_subscription_status_serialize(
            subscription_id=subscription_id,
            event_status_update=event_status_update,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventStatusUpdate",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _change_webhook_subscription_status_serialize(
        self,
        subscription_id,
        event_status_update,
        x_external_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscription_id'] = subscription_id
        # process the query parameters
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter
        if event_status_update is not None:
            _body_params = event_status_update


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/notification-subscriptions/webhooks/{subscription_id}/status',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_webhook_subscription(
        self,
        subscription: Annotated[Subscription, Field(description="Request body for creating event subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SubscriptionDetail:
        """Create Webhook Subscription

        Creates a new webhook subscription for receiving event notifications. You can specify the URL for receiving notifications and select the events to subscribe to, including any conditions for filtering. Each partner can have multiple subscriptions, and each subscription can cover multiple events. The API supports URL overrides at the event level, ensuring that each subscription is tailored to specific events and their respective requirements.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription: Request body for creating event subscription. (required)
        :type subscription: Subscription
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_webhook_subscription_serialize(
            subscription=subscription,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SubscriptionDetail",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_webhook_subscription_with_http_info(
        self,
        subscription: Annotated[Subscription, Field(description="Request body for creating event subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SubscriptionDetail]:
        """Create Webhook Subscription

        Creates a new webhook subscription for receiving event notifications. You can specify the URL for receiving notifications and select the events to subscribe to, including any conditions for filtering. Each partner can have multiple subscriptions, and each subscription can cover multiple events. The API supports URL overrides at the event level, ensuring that each subscription is tailored to specific events and their respective requirements.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription: Request body for creating event subscription. (required)
        :type subscription: Subscription
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_webhook_subscription_serialize(
            subscription=subscription,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SubscriptionDetail",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_webhook_subscription_without_preload_content(
        self,
        subscription: Annotated[Subscription, Field(description="Request body for creating event subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Webhook Subscription

        Creates a new webhook subscription for receiving event notifications. You can specify the URL for receiving notifications and select the events to subscribe to, including any conditions for filtering. Each partner can have multiple subscriptions, and each subscription can cover multiple events. The API supports URL overrides at the event level, ensuring that each subscription is tailored to specific events and their respective requirements.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription: Request body for creating event subscription. (required)
        :type subscription: Subscription
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_webhook_subscription_serialize(
            subscription=subscription,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SubscriptionDetail",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_webhook_subscription_serialize(
        self,
        subscription,
        x_external_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter
        if subscription is not None:
            _body_params = subscription


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/notification-subscriptions/webhooks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_webhook_subscription(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete Webhook Subscription

        Deletes a subscription specified by its ID. Once deleted, the subscription and its associated events will no longer be active or receive notifications   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_webhook_subscription_serialize(
            subscription_id=subscription_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_webhook_subscription_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete Webhook Subscription

        Deletes a subscription specified by its ID. Once deleted, the subscription and its associated events will no longer be active or receive notifications   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_webhook_subscription_serialize(
            subscription_id=subscription_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_webhook_subscription_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Webhook Subscription

        Deletes a subscription specified by its ID. Once deleted, the subscription and its associated events will no longer be active or receive notifications   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_webhook_subscription_serialize(
            subscription_id=subscription_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_webhook_subscription_serialize(
        self,
        subscription_id,
        x_external_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscription_id'] = subscription_id
        # process the query parameters
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/notification-subscriptions/webhooks/{subscription_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_webhook_subscription_event(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete Webhook Subscription Event

        Deletes a specific webhook event from a subscription identified by subscription Id and webhook Event Id.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_webhook_subscription_event_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_webhook_subscription_event_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete Webhook Subscription Event

        Deletes a specific webhook event from a subscription identified by subscription Id and webhook Event Id.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_webhook_subscription_event_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_webhook_subscription_event_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Webhook Subscription Event

        Deletes a specific webhook event from a subscription identified by subscription Id and webhook Event Id.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_webhook_subscription_event_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_webhook_subscription_event_serialize(
        self,
        subscription_id,
        webhook_event_id,
        x_external_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscription_id'] = subscription_id
        if webhook_event_id is not None:
            _path_params['webhook_event_id'] = webhook_event_id
        # process the query parameters
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/notification-subscriptions/webhooks/{subscription_id}/events/{webhook_event_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_webhook_subscription_by_id(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SubscriptionDetail:
        """Get Webhook Subscription Details

        Retrieves detailed information about a specific webhook subscription using the provided subscription ID. The response includes subscription details such as the events, conditions, and current status.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_webhook_subscription_by_id_serialize(
            subscription_id=subscription_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubscriptionDetail",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_webhook_subscription_by_id_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SubscriptionDetail]:
        """Get Webhook Subscription Details

        Retrieves detailed information about a specific webhook subscription using the provided subscription ID. The response includes subscription details such as the events, conditions, and current status.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_webhook_subscription_by_id_serialize(
            subscription_id=subscription_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubscriptionDetail",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_webhook_subscription_by_id_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Webhook Subscription Details

        Retrieves detailed information about a specific webhook subscription using the provided subscription ID. The response includes subscription details such as the events, conditions, and current status.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_webhook_subscription_by_id_serialize(
            subscription_id=subscription_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubscriptionDetail",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_webhook_subscription_by_id_serialize(
        self,
        subscription_id,
        x_external_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscription_id'] = subscription_id
        # process the query parameters
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/notification-subscriptions/webhooks/{subscription_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_available_webhook_subscription_events(
        self,
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListAvailableWebhookSubscriptionEvents200Response:
        """List Available Webhook Subscription Events

        Allows partners to retrieve a list of all event subscriptions supported by the Open Finance system.  This endpoint provides information about each subscription, including the webhook URL and associated events, enabling partners to understand all available subscription options.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_available_webhook_subscription_events_serialize(
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListAvailableWebhookSubscriptionEvents200Response",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_available_webhook_subscription_events_with_http_info(
        self,
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListAvailableWebhookSubscriptionEvents200Response]:
        """List Available Webhook Subscription Events

        Allows partners to retrieve a list of all event subscriptions supported by the Open Finance system.  This endpoint provides information about each subscription, including the webhook URL and associated events, enabling partners to understand all available subscription options.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_available_webhook_subscription_events_serialize(
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListAvailableWebhookSubscriptionEvents200Response",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_available_webhook_subscription_events_without_preload_content(
        self,
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Available Webhook Subscription Events

        Allows partners to retrieve a list of all event subscriptions supported by the Open Finance system.  This endpoint provides information about each subscription, including the webhook URL and associated events, enabling partners to understand all available subscription options.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_available_webhook_subscription_events_serialize(
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListAvailableWebhookSubscriptionEvents200Response",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_available_webhook_subscription_events_serialize(
        self,
        x_external_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/notification-subscriptions/webhooks/events',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_webhook_subscriptions(
        self,
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Index of the page of results to return.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Maximum number of results per page.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Subscriptions:
        """List Webhook Subscriptions

        Retrieves a list of all webhook subscriptions. The response includes details of each subscription, such as the subscription ID, URL, events, and their conditions. This API provides an overview of all active and inactive subscriptions.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param offset: Index of the page of results to return.
        :type offset: int
        :param limit: Maximum number of results per page.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_webhook_subscriptions_serialize(
            x_external_request_id=x_external_request_id,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Subscriptions",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_webhook_subscriptions_with_http_info(
        self,
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Index of the page of results to return.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Maximum number of results per page.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Subscriptions]:
        """List Webhook Subscriptions

        Retrieves a list of all webhook subscriptions. The response includes details of each subscription, such as the subscription ID, URL, events, and their conditions. This API provides an overview of all active and inactive subscriptions.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param offset: Index of the page of results to return.
        :type offset: int
        :param limit: Maximum number of results per page.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_webhook_subscriptions_serialize(
            x_external_request_id=x_external_request_id,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Subscriptions",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_webhook_subscriptions_without_preload_content(
        self,
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Index of the page of results to return.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Maximum number of results per page.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Webhook Subscriptions

        Retrieves a list of all webhook subscriptions. The response includes details of each subscription, such as the subscription ID, URL, events, and their conditions. This API provides an overview of all active and inactive subscriptions.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param offset: Index of the page of results to return.
        :type offset: int
        :param limit: Maximum number of results per page.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_webhook_subscriptions_serialize(
            x_external_request_id=x_external_request_id,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Subscriptions",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_webhook_subscriptions_serialize(
        self,
        x_external_request_id,
        offset,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/notification-subscriptions/webhooks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def test_webhook_subscription(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Test Webhook Subscription Based on Subscription id

        Test all the webhook event under the given webhook subscription using subscription_id. _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._test_webhook_subscription_serialize(
            subscription_id=subscription_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def test_webhook_subscription_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Test Webhook Subscription Based on Subscription id

        Test all the webhook event under the given webhook subscription using subscription_id. _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._test_webhook_subscription_serialize(
            subscription_id=subscription_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def test_webhook_subscription_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Test Webhook Subscription Based on Subscription id

        Test all the webhook event under the given webhook subscription using subscription_id. _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._test_webhook_subscription_serialize(
            subscription_id=subscription_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _test_webhook_subscription_serialize(
        self,
        subscription_id,
        x_external_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscription_id'] = subscription_id
        # process the query parameters
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/notification-subscriptions/webhooks/{subscription_id}/test-subscriptions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def test_webhook_subscription_based_on_event_id(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Test Webhook Subscription Based on Subscription id & Webhook event id.

        Test the webhook event under the given webhook subscription using subscription_id & webhook event id. _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._test_webhook_subscription_based_on_event_id_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def test_webhook_subscription_based_on_event_id_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Test Webhook Subscription Based on Subscription id & Webhook event id.

        Test the webhook event under the given webhook subscription using subscription_id & webhook event id. _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._test_webhook_subscription_based_on_event_id_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def test_webhook_subscription_based_on_event_id_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Test Webhook Subscription Based on Subscription id & Webhook event id.

        Test the webhook event under the given webhook subscription using subscription_id & webhook event id. _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._test_webhook_subscription_based_on_event_id_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _test_webhook_subscription_based_on_event_id_serialize(
        self,
        subscription_id,
        webhook_event_id,
        x_external_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscription_id'] = subscription_id
        if webhook_event_id is not None:
            _path_params['webhook_event_id'] = webhook_event_id
        # process the query parameters
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/notification-subscriptions/webhooks/{subscription_id}/events/{webhook_event_id}/test-subscriptions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_webhook_subscription(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        subscription: Annotated[Subscription, Field(description="Request body for updating event subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SubscriptionDetail:
        """Update Webhook Subscription

        Updates an existing webhook subscription with the specified subscription ID. You can modify the subscription URL and the events associated with it.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param subscription: Request body for updating event subscription. (required)
        :type subscription: Subscription
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_webhook_subscription_serialize(
            subscription_id=subscription_id,
            subscription=subscription,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubscriptionDetail",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_webhook_subscription_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        subscription: Annotated[Subscription, Field(description="Request body for updating event subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SubscriptionDetail]:
        """Update Webhook Subscription

        Updates an existing webhook subscription with the specified subscription ID. You can modify the subscription URL and the events associated with it.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param subscription: Request body for updating event subscription. (required)
        :type subscription: Subscription
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_webhook_subscription_serialize(
            subscription_id=subscription_id,
            subscription=subscription,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubscriptionDetail",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_webhook_subscription_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        subscription: Annotated[Subscription, Field(description="Request body for updating event subscription.")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Webhook Subscription

        Updates an existing webhook subscription with the specified subscription ID. You can modify the subscription URL and the events associated with it.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param subscription: Request body for updating event subscription. (required)
        :type subscription: Subscription
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_webhook_subscription_serialize(
            subscription_id=subscription_id,
            subscription=subscription,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubscriptionDetail",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_webhook_subscription_serialize(
        self,
        subscription_id,
        subscription,
        x_external_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscription_id'] = subscription_id
        # process the query parameters
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter
        if subscription is not None:
            _body_params = subscription


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/notification-subscriptions/webhooks/{subscription_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_webhook_subscription_event(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        webhook_event: Annotated[WebhookEvent, Field(description="Request body to update Event")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WebhookEvent:
        """Update Webhook Subscription Event

        Updates a specific webhook event in a subscription. Use subscription Id and webhook Event Id to identify the event and modify its details.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param webhook_event: Request body to update Event (required)
        :type webhook_event: WebhookEvent
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_webhook_subscription_event_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            webhook_event=webhook_event,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookEvent",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_webhook_subscription_event_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        webhook_event: Annotated[WebhookEvent, Field(description="Request body to update Event")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WebhookEvent]:
        """Update Webhook Subscription Event

        Updates a specific webhook event in a subscription. Use subscription Id and webhook Event Id to identify the event and modify its details.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param webhook_event: Request body to update Event (required)
        :type webhook_event: WebhookEvent
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_webhook_subscription_event_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            webhook_event=webhook_event,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookEvent",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_webhook_subscription_event_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook subscription.")],
        webhook_event_id: Annotated[StrictStr, Field(description="A unique UUID identifier of a webhook event.")],
        webhook_event: Annotated[WebhookEvent, Field(description="Request body to update Event")],
        x_external_request_id: Annotated[Optional[StrictStr], Field(description="A unique identifier for the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Webhook Subscription Event

        Updates a specific webhook event in a subscription. Use subscription Id and webhook Event Id to identify the event and modify its details.   _Supported regions_: ![ðŸ‡ºðŸ‡¸](https://flagcdn.com/20x15/us.png)

        :param subscription_id: A unique UUID identifier of a webhook subscription. (required)
        :type subscription_id: str
        :param webhook_event_id: A unique UUID identifier of a webhook event. (required)
        :type webhook_event_id: str
        :param webhook_event: Request body to update Event (required)
        :type webhook_event: WebhookEvent
        :param x_external_request_id: A unique identifier for the request.
        :type x_external_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_webhook_subscription_event_serialize(
            subscription_id=subscription_id,
            webhook_event_id=webhook_event_id,
            webhook_event=webhook_event,
            x_external_request_id=x_external_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookEvent",
            '400': "ErrorWrapper",
            '401': "ErrorWrapper",
            '404': "ErrorWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_webhook_subscription_event_serialize(
        self,
        subscription_id,
        webhook_event_id,
        webhook_event,
        x_external_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscription_id'] = subscription_id
        if webhook_event_id is not None:
            _path_params['webhook_event_id'] = webhook_event_id
        # process the query parameters
        # process the header parameters
        if x_external_request_id is not None:
            _header_params['X-External-Request-Id'] = x_external_request_id
        # process the form parameters
        # process the body parameter
        if webhook_event is not None:
            _body_params = webhook_event


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'FinicityAppToken', 
            'FinicityAppKey'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/notification-subscriptions/webhooks/{subscription_id}/events/{webhook_event_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


